# 线性表

## 定义

是由n(n≧0)个数据元素(结点)a1，a2，…an组成的有限序列。该序列中的所有结点具有相同的数据类型。其中数据元素的个数n称为线性表的长度。

当n=0时，称为空表。 
当n>0时，将非空的线性表记作：(a1，a2，…an)

### 前驱和后继

a1称为线性表的第一个（首）结点，an称为线性表的最后一个（尾）结点。  
a1，a2，…ai-1都是ai(2≦i≦n)的前驱，其中ai-1是ai的直接前驱;  
ai+1，ai+2，…an都是ai(1≦i ≦n-1)的后继，其中ai+1是ai的直接后继。

### 数据项、域和关键字

线性表中的结点可以是记录型元素，每个元素含有多个数据项，每个项称为结点的一个**域**。  
每个元素有一个可以唯一标识每个结点的数据项组，称为关键字。

## 顺序存储——顺序表

把线性表的结点按逻辑顺序依次存放在一组地址连续的存储单元里。  
用这种方法存储的**线性表**简称**顺序表**。

### 插入

挪动一堆结点，腾出了空，再把元素放进去。复杂度为O(n)

步骤：
1. 将线性表L中的第i个至第n个结点后移一个位置。
2. 将结点e插入到结点ai-1之后。 
3. 线性表长度加1。

注意最后长度加一

### 删除

前移一堆结点，覆盖掉要删除的结点。复杂度为O(n)

步骤：
1. 将线性表L中的第i+1个至第n个结点依此向前移动一个位置。
2. 线性表长度减1。


### 定位删除

不断地比较，直到找到，然后再删除。复杂度为O(n)

步骤：
1. 在线性表L查找值为x的第一个数据元素。
2. 将从找到的位置至最后一个结点依次向前移动一个位置。  
3. 线性表长度减1。

## 链式存储——链表

既存储数据，也存储其直接后继结点的地址，称为指针(pointer)或链(link)，这两部分组成了链表中的结点结构。

链表是通过每个结点的指针域将线性表的n个结点按其逻辑次序链接在一起的。  
每一个结点只包含一个指针域的链表，称为单链表。  
为操作方便，总是在链表的第一个结点之前附设一个头结点(头指针)head指向第一个结点。  
头结点的数据域可以不存储任何信息(或链表长度等信息)。

### 创建链表

**头插法**

把新输入的结点塞到head和链表第一个元素之间

    p= (LNode*)malloc(sizeof(LNode));
    p–>data = data;   /*数据域赋值*/
    p–>next = head–>next;
    head–>next = p

**尾插法**

总共要三个指针

	q= (LNode*)malloc(sizeof(LNode)); 
	q–>data = data;   /*   数据域赋值  */
	q–>next = p–>next;
    p–>next = q;
    p=q; /*钩链，新创建的结点总是作为最后一个结点*/

#### 复杂度与约定

无论是哪种插入方法，如果要插入建立的单线性链表的结点是n个，算法的时间复杂度均为O(n)。

对于单链表，无论是哪种操作，只要涉及到钩链（或重新钩链），如果没有明确给出直接后继，钩链的次序必须是“先右后左”。

### 单链表的查找

#### 按序号查找

取单链表中的第i个元素。

对于单链表，不能象顺序表中那样直接按序号i访问结点，  
而只能从链表的头结点出发，沿链域next逐个结点往下搜索，  
直到搜索到第i个结点为止。  
因此，链表不是随机存取结构。

设单链表的长度为n，要查找表中第i个结点，仅当1≦i≦n时，i的值是合法的。  
复杂度O(n)

#### 按值查找

按值查找是在链表中，查找是否有结点值等于给定值key的结点  
若有，则返回首次找到的值为key的结点的存储位置；否则返回NULL。  
查找时从开始结点出发，沿链表逐个将结点的值和给定值key作比较。

复杂度O(n)

### 插入和删除

复杂度都是O(n)  
删除记得free就好了

### 有序链表的合并

合并前：  
![两个有序的链表](/img/1-Notes/1-线性表/链表的合并-1.jpg)

合并了一个：  
![刚开始合并的两边](/img/1-Notes/1-线性表/链表的合并-2.jpg)

具体操作：  
算法中pa，pb分别是待考察的两个链表的当前结点，pc是合并过程中合并的链表的最后一个结点。  
从两个链表里面，挑个最小的，插到新链表的尾巴上，这个尾巴就是pc，然后pa或者pb要后移

复杂度为O(m+n)