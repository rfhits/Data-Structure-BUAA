# 串

## 概念

串(字符串)：是零个或多个字符组成的**有限**序列。  
记作：S=“a1a2a3…”，  
其中S是串名，ai(1≦i≦n)是单个，可以是字母、数字或其它字符。

串值：双引号括起来的字符序列是串值。

串长：串中所包含的字符个数称为该串的长度。

空串(空的字符串)：长度为零的串称为空串，它不包含任何字符。

空格串(空白串)：构成串的所有字符都是空格的串称为空白串。

子串(substring)：串中任意个连续字符组成的子序列称为该串的子串，包含子串的串相应地称为主串。

子串的序号：  
将子串在主串中首次出现时的该子串的首字符对应在主串中的序号，  
称为子串在主串中的序号（或位置）。  
例如，设有串A和B分别是：  
A=“这是字符串”，B=“是”  
则B是A的子串，A为主串。B在A中出现了一次，B在A中的序号为2。

串相等：如果两个串的串值相等（相同），称这两个串相等。  
换言之，只有当两个串的长度相等，且各个对应位置的字符都相同时才相等。

通常在程序中使用的串可分为两种：串变量和串常量。  
串常量和整常数、实常数一样，在程序中只能被引用但不能不能改变其值，即**只能读不能写**  
通常串常量是由直接量来表示的，例如语句错误（“溢出”）中“溢出”是直接量。  
串变量和其它类型的变量一样，其值是可以改变。

## 串的存储表示和实现

串是一种特殊的线性表，其存储表示和线性表类似，但又不完全相同。  
串的存储方式取决于将要对串所进行的操作。串在计算机中有3种表示方式：
1. 定长顺序存储表示：  
   将串定义成**字符数组**，利用串名可以直接访问串值。  
   用这种表示方式，串的存储空间在编译时确定，其大小不能改变。

2. 堆分配存储方式：
   仍然用一组地址连续的存储单元来依次存储串中的字符序列，  
   但串的存储空间是在程序运行时根据串的实际长度**动态**分配的。

3. 块链存储方式：是一种链式存储结构表示。

### 定长顺序存储

这种存储结构又称为串的顺序存储结构。  
用一组连续的存储单元来存放串中的字符序列。  
所谓定长顺序存储结构，是直接使用定长的字符数组来定义，数组的上界预先确定。  
定长顺序存储结构定义为：

    #define MAX_STRLEN  256
    typedef  struct
    {
        char  str[MAX_STRLEN] ;
        int  length;
    } StringType ; 

### 堆分配存储

系统提供一个空间足够大且地址连续的存储空间（称为“堆”）供串使用。  
可使用C语言的动态存储分配函数malloc()和free()来管理。

特点是：  
仍然以一组地址连续的存储空间来存储字符串值，  
但其所需的存储空间是在程序执行过程中动态分配，故是动态的，变长的。

串的堆式存储结构的类型定义：

    typedef  struct
    {  
        char *ch;    /*  若非空，按长度分配，否则为NULL */
        int length;  /*  串的长度  */
    } HString ;

### 串的链式存储表示

串的链式存储结构和线性表的串的链式存储结构类似，  
采用单链表来存储串，结点的构成是：
1. data域：存放字符，data域可存放的字符个数称为结点的大小；
2. next域：存放指向下一结点的指针。

若每个结点仅存放一个字符，则结点的指针域就非常多，造成系统空间浪费，  
为节省存储空间，考虑串结构的特殊性，  
使每个结点存放若干个字符，  
这种结构称为块链结构。

## 模式匹配

子串在主串中的定位称为模式匹配或串匹配（字符串匹配）。  
模式匹配成功是指在主串S中能够找到模式串T，  
否则，称模式串T在主串S中不存在。

### Brute-Force

暴力匹配，不做评价。

当第一次sk≠tj时：  
主串要退回到k-j+1的位置，  
而模式串也要退回到第一个字符（即j=0的位置）。

该算法的时间复杂度为O(n*m)，其中n、m分别是主串和模式串的长度。  
运行过程中，该算法的执行时间近似于O(n+m)

### KMP

主串和子串逐个匹配，总有匹配失败的时候，sk≠tj  
这时候，主串和模式串退的地方有技巧：  
主串不会退，仅仅模式串回退。

网络上流行的KMP算法主要有两种，  
一种从最长公共前后缀的角度，比较好理解，  
而另一种是对第一种的优化，效率高，但是，，本菜鸡看不懂。

常用的表述：  
k表示最近的，塞到next里的值，  
i表示pattern（模式串）的遍历序号

拿“abcadabc”举例：  

已知：  
a, b, c, a, d, a, b对应的next为：  
0, 0, 0, 1, 0, 1, 2  
要加上c对应的next，  
应当先看c前面那个字母b，  
b下面那个next，就是k，等于2，看pat[2]和“c”的关系，  
如果pat[2] == "c"，则目前为止的公共前后缀可以继续推进——c对应的next为3。  
如果pat[2] != "c"，或者说，要加个"d"进去，  
就要进行迭代，迭代的前提是现在的k不能为0，  
否则最后会陷入一直自我迭代，  
如果k != 0，那么k = next[k]。  
最后，把-1给insert到next里，整个next右平移一格。

总结下：  
1. next[0]，即第一个a对应next为0
2. 算next[i]，先检查p[k]是否和p[i]相等
3. 相等，皆大欢喜
4. 不相等，得确定k是不是0，
5. 是的话，完了，这个next[i]也得是0
6. 不是的话，进行迭代，回到2
7. 最后，平移加上插入。

代码：

    def gen_next(pat):
        k, i, l = 0, 1, len(pat)
        next = [0]*l
        if l == 0:
            return False
        while i < l:
            if pat[i] == pat[k]:
                k += 1
                next[i] = k
                i += 1
            else:
                if k == 0:
                    next[i] = 0
                    i += 1
                else:
                    k = next[k]
        return [-1] + next[0:-1]

至于search的代码，这个比较固定：

    def KMP_search(text, pat):
        i, j = 0, 0
        n, m = len(text), len(pat)
        next = gen_next(pat)
        while(i < n and j <= m):
            if(text[i] == pat[j] or j == -1):
                i += 1
                j += 1
            else:
                j = next[j]  # pat slide
        if(j == m):
            return i-j
        else:
            return -1

算法的复杂度是O(m+n)