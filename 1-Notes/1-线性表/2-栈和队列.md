# 栈和队列

栈和队列是两种应用非常广泛的数据结构，它们都来自线性表数据结构，都是“操作受限”的线性表。

栈在计算机的实现有多种方式：
1. 硬堆栈：利用CPU中的某些寄存器组或类似的硬件或使用内存的特殊区域来实现。这类堆栈容量有限，但速度很快；
2. 软堆栈：这类堆栈主要在内存中实现。堆栈容量可以达到很大。在实现方式上，又有动态方式和静态方式两种。

本章将讨论栈和队列的基本概念、存储结构、基本操作以及这些操作的具体实现。


## 栈(Stack)

### 概念

栈：是限制在表的一端进行插入和删除操作的线性表。  
又称为后进先出LIFO(Last In First Out)或  
先进后出FILO(First In Last Out)线性表。

栈顶(Top)：允许进行插入、删除操作的一端，又称为表尾。用栈顶指针(top)来指示栈顶元素。

栈底(Bottom)：是固定端，又称为表头。

空栈：当表中没有元素时称为空栈。

栈的顺序存储结构简称为顺序栈，和线性表相类似，用一维数组来存储栈。  
根据数组是否可以根据需要增大，  
又可分为静态顺序栈和动态顺序栈。
1. 静态顺序栈实现简单，但不能根据需要增大栈的存储空间；
2. 动态顺序栈可以根据需要增大栈的存储空间，但实现稍为复杂。

### 动态顺序栈

采用动态一维数组来存储栈。所谓动态，  
指的是栈的大小可以根据需要增加。  
python中的list有动态栈的这种特性

1. 用bottom表示栈底指针，栈底固定不变的；栈顶则随着进栈和退栈操作而变化。用top(称为栈顶指针)指示当前栈顶位置。
2. 用top = bottom作为栈空的标记，每次top指向栈顶数组中的下一个存储位置。
3. **结点进栈**：首先将数据元素保存到栈顶（top所指的当前位置），然后执行top加1，使top指向栈顶的下一个存储位置;
4. 结点出栈：首先执行top减1，使top指向栈顶元素的存储位置，然后将栈顶元素取出

代码：

    class SStack():

    def __init__(self):
        self.elems = []
    
    def is_empty(self):
        return self.elems == []
    
    def top(self):
        if self.elems == []:
            raise StackUnderflow
        return self.elems[len(self.elems)-1]

    def push(self, elem):
        self.elems.append(elem)

    def pop(self):
        if self.elems == []:
            raise StackUnderflow
        return self.elems.pop()

###  静态顺序栈

采用静态一维数组来存储栈。  
C语言中的数组有这种特性  
栈底固定不变的，而栈顶则随着进栈和退栈操作变化的
1. 栈底固定不变的，栈顶则随着进栈和退栈操作而变化，用一个整型变量top（称为栈顶指针）来指示当前栈顶位置。
2. 用top=0表示栈空的初始状态，每次top指向栈顶在数组中的存储位置。 
3. 结点进栈：**首先执行top加1**，使top指向新的栈顶位置，然后将数据元素保存到栈顶（top所指的当前位置）
4. 结点出栈：首先把top指向的栈顶元素取出，然后执行top减1，使top指向新的栈顶位置。

### 栈链

![栈链存储形式](/img/1-Notes/1-线性表/栈链存储形式.jpg)  
每次压栈，就相当于在top和上一个元素之间插入一个结点

### 栈的应用

#### 进制转换

将余数压栈

    def Conversion(n,d):
        myStack=SStack();
        while (n>0):
            myStack.push(n%d)   // 余数被压进去
            n//=d
        while(not myStack.is_empty()):
            print (myStack.pop(),end="")    // 按照栈序输出
        print("")

#### 括号匹配

经典问题，once match, once pop.

#### 递归调用

栈的另一个重要应用是在程序设计语言中实现递归调用。  
按照我个人写汇编的理解，就是将当前状态保存到栈里面，进入函数直到结尾，返回时再把状态取出来。

## 队列(Queue)

就是first in first out

### 概念

队列：也是运算受限的线性表。  
是一种先进先出(First In First Out，简称FIFO)的线性表。  
只允许在表的一端进行插入，而在另一端进行删除。

队首(front)：允许进行删除的一端称为队首。  
队尾(rear)：允许进行插入的一端称为队尾。

例如：排**队**购物。操作系统中的作业排队。先进入队列的成员总是先离开队列。　　

利用一组连续的存储单元（一维数组）依次存放从队首到队尾的各个元素，称为顺序队列。  
对于队列，和顺序栈相类似，也有动态和静态之分。本部分介绍的是静态顺序队列。

### 具体操作

设立一个队首指针front，一个队尾指针rear，分别指向队首和队尾元素。
1. 初始化：front=rear=0。
2. 入队：将新元素插入rear所指的位置，然后rear加1。
3. 出队：删去front所指的元素，然后加1并返回被删元素。
4. 队列为空：front=rear。
5. 队满：rear=MAX_QUEUE_SIZE-1或front=rear。

**假溢出**

因为在入队和出队操作中，头、尾指针只增加不减小，  
致使被删除元素的空间永远无法重新利用。  
因此，尽管队列中实际元素个数可能远远小于数组大小，  
但可能由于尾指针已超出向量空间的上界而不能做入队操作。

![队列的假溢出](/img/1-Notes/1-线性表/队列的假溢出.jpg)

### 循环队列

克服上述“假溢出”的方法是：  
将为队列分配的向量空间看成为一个首尾相接的圆环，并称这种队列为循环队列(Circular Queue)。

在循环队列中进行出队、入队操作时，队首、队尾指针仍要加1，朝后移动。  
只不过当队首、队尾指针指向向量上界(MAX_QUEUE_SIZE-1)时，  
其加1操作的结果是指向向量的下界0。

用模运算可简化为：i=(i+1)%MAX_QUEUE_SIZE;
显然，为循环队列所分配的空间可以被充分利用，除非向量空间真的被队列元素全部占用，否则不会上溢。  
因此，真正实用的顺序队列是循环队列。

约定入队前，测试尾指针在循环意义下加1后是否等于头指针，若相等则认为队满。即：
1. rear所指的单元始终为空
2. 循环队列为空：front=rear
3. 循环队列满：(rear+1)%MAX_QUEUE_SIZE =front

这也意味着，实用的静态队列，总是有一个位置是空的。

### 链队列

队列的链式存储结构简称为链队列，它是限制仅在表头进行删除操作和表尾进行插入操作的单链表。  
需要两类不同的结点：数据元素结点，队列的队首指针和队尾指针的结点

链队的操作实际上是单链表的操作，  
只不过是删除在表头进行，插入在表尾进行。插入、删除时分别修改不同的指针。  
链队运算及指针变化如图所示：  
![链队列操作及指针变化](/img/1-Notes/1-线性表/链队列操作及指针变化.jpg)

用一维数组实现队列，是保证rear为空；  
用链表实现队列，是保证head为空。  
这回是保证每个元素被逐个加到链表的最后面。
