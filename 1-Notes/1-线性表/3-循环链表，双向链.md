# 循环链表，双向链表和串

## 循环链表(Circular Linked List)

是一种头尾相接的链表。  
其特点是最后一个结点的指针域指向链表的头结点，整个链表的指针域链接成一个环。

从循环链表的任意一个结点出发都可以找到链表中的其它结点，使处理更加方便灵活。

### 循环链表的操作

对于单循环链表，除链表的合并外，其它的操作和单线性链表基本上一致，仅仅需要在单线性链表操作算法基础上作以下简单修改：
1. 判断是否是空链表：head->next == head
2. 判断是否是表尾结点：p->next == head


## 双向链表(Double Linked List)

指的是构成链表的每个结点中设立两个指针域：  
一个指向其直接前趋的指针域prior，  
一个指向其直接后继的指针域next。  
这样形成的链表中有两个方向不同的链，故称为双向链表。

和单链表类似，双向链表一般增加头指针也能使双链表上的某些运算变得方便。  
将头结点和尾结点链接起来也能构成循环链表，并称之为双向循环链表。  
双向链表是为了克服单链表的单向性的缺陷而引入的。

### 双向链表的插入

![双向链表的插入](/img/1-Notes/1-线性表/双向链表的插入.jpg)

插入时仅仅指出直接前驱结点，钩链时必须注意先后次序是： “先右后左”。  
部分语句组如下：

    S=(DulNode*)malloc(sizeof(DulNode)); 
    S->data = e;
    S->next = p->next;  // 先右
    p->next -> prior=S;

    p->next = S;        // 后左
    S->prior = p;    /*  钩链次序非常重要  */

### 双向链表的删除

设要删除的结点为p ，删除时可以不引入新的辅助指针变量，  
可以直接先断链，再释放结点。   
部分语句组如下：

    p->prior->next = p->next;
    p->next->prior = p->prior;
    free(p);
