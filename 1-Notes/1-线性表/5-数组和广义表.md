# 数组和广义表

数组这种数据结构可以看成是线性表的推广。  
科学计算中涉及到大量的矩阵问题，在程序设计语言中一般都采用数组来存。  
但当矩阵规模很大且具有特殊结构（对角矩阵、三角矩阵、对称矩阵、稀疏矩阵等），  
为减少程序的时间和空间需求，采用**自定义**的描述方式。

数组是一组偶对（下标值，数据元素值）的集合。  
在数组中，对于一组有意义的下标，都存在一个与其对应的值。  
一维数组对应着一个下标值，二维数组对应着两个下标值，如此类推。

数组是由n(n>1)个具有相同数据类型的数据元素a1，a2，…，an组成的有序序列，且该序列必须存储在一块地址连续的存储单元中。

## 数组的特点

数组中的数据元素具有相同数据类型。  
数组是一种随机存取结构：  
给定一组下标，就可以访问与其对应的数据元素。  
数组中的数据元素个数是固定的。

## 数组的顺序表示和实现

数组一般不做插入和删除操作，  
也就是说，数组一旦建立，结构中的元素个数和元素间的关系就不再发生变化。  
因此，一般都是采用顺序存储的方法来表示数组。

计算机的内存结构是一维（线性）地址结构，对于多维数组，将其存放(映射)到内存一维结构时，  
有个次序约定问题。即——  
必须按某种次序将数组元素排成一列序列，然后将这个线性序列存放到内存中。

二维数组是最简单的多维数组，以此为例说明多维数组存放(映射)到内存一维结构时的次序约定问题。

### 行优先顺序(Row Major Order)

对于二维m×n数组：  
a_(11), a_(12),..., a_(1n), a(21),..., a(2n),...

a_(ij)对应的地址就是：Loc[a_(11)] + [(i-1) * n + (j-1)] * L  
即：  
Loc[a_(ij)] = Loc[a_(11)] + [(i-1) * n + (j-1)] * L  
L表示每个元素占据的存储单元的大小

对于三维数组：  
Loc[a_(ijk)] = Loc[a_(111)] + [(i-1) * n * p + (j-1) * p + (k-1)] * L

### 列优先顺序(Column Major Order) 

对于二维m×n数组：  
a_(11), a_(21),..., a_(m1), a_(12),..., a_(m2),...

Loc[a_(ij)] = Loc[a_(11)] + [(i-1) + (j-1) * m] * L

## 矩阵的压缩存储

### 对称矩阵

PPT中是以“按行优先存储下三角形（包括对角线）中的元素。”为准。  
用一维数组（向量）sa[0…n(n+1)/2]来存储n阶对称矩阵。  
![以下三角存储对称矩阵中的元素](/img/1-Notes/1-线性表/以“下三角”存储对称矩阵中的元素.jpg)  
![对称矩阵的压缩存储示例](/img/1-Notes/1-线性表/对称矩阵的压缩存储示例.jpg)

K[a_(ij)] = i(i-1)/2 + j  


推导：  
![对称矩阵元素与向量间的对应关系](/img/1-Notes/1-线性表/对称矩阵元素与向量间的对应关系.png)  
若K从0开始，则只需将最后结果减一：  
K[a_(ij)] = i(i-1)/2 + j - 1  
这是i <= j的情况，i > j时，将ij对调即可。

### 三角矩阵

以主对角线划分，三角矩阵有上三角和下三角两种。  
上三角矩阵的下三角（不包括主对角线）中的元素均为常数c(一般为0)。  
下三角矩阵正好相反，它的主对角线上方均为常数。  
![三角矩阵示例](/img/1-Notes/1-线性表/三角矩阵示例.jpg)

看个人喜好，要将常数保存在sa的头还是尾。  
建议保存在尾部，和对称矩阵保持一致。  
以存储下三角矩阵为例：  
K[a_(ij)] = i(i-1)/2 + j - 1  
i > j时，K[a_(ij)] = n(n+1)/2

### 稀疏矩阵(Sparse Matrix)

对于稀疏矩阵，目前还没有一个确切的定义。  
设矩阵A是一个n×m的矩阵中有s个非零元素，设 δ=s/(n×m)，称δ为稀疏因子，  
如果某一矩阵的稀疏因子δ满足δ≦0.05时称为稀疏矩阵。

对于稀疏矩阵，采用压缩存储方法时，只存储非0元素。  
必须存储非0元素的行下标值、列下标值、元素值。  
因此，一个三元组(i, j, a_ij)唯一确定稀疏矩阵的一个非零元素。

    typedef int elemtype;
    typedef struct
    {
        int row;     /*  行下标  */
        int col;     /*  列下标  */
        elemtype value;     /*  元素值  */
    }Triple ;

    typedef struct 
    {   
        int  rn ;   /*   行数：row number   */
        int  cn ;   /*   列数  column number */
        int  tn ;   /*    非0元素个数   */
        Triple   data[MAX_SIZE] ; 
    }TMatrix ;

![稀疏矩阵的三元组表](/img/1-Notes/1-线性表/稀疏矩阵的三元组表.jpg)

## 稀疏矩阵转置

![稀疏矩阵三元组的转置](/img/1-Notes/1-线性表/稀疏矩阵三元组的转置.jpg)

如果直接交换row和col的值，可能导致三元组表的顺序颠倒。

### 遍历col转置

遍历矩阵A的col，  
先是A矩阵col为1的存进矩阵B里；  
然后A矩阵col为2的存进矩阵B里；  
以此类推。

    void TransMatrix(TMatrix a , TMatrix b){
        int p , q , col ;
        b.rn = a.cn;  b.cn = a.rn; b.tn = a.tn;
        if (b.tn == 0){
            printf(“The Matrix A=0\n” );
        }
        else{
            q=0;
            for(col = 1; col <= a.cn; col++){
                for(p = 0; p < a.tn; p++){
                    if(a.data[p].col == col){
                        b.data[q].row = a.data[p].col;
                        b.data[q].col = a.data[p].row; 
                        b.data[q].value = a.data[p].value; 
                        q++ ;
                    }
                }
            }
        }
    }

复杂度为O(cn×tn)，即矩阵的列数和非0元素的个数的乘积成正比。

### 快速转置

如果知道三元表中每一项在转置后的新的三元表中的位置，  
然后直接放进去，可以极大的缩小了时间复杂度。

因此，应先求得A中每一列的非0元素个数。
附设两个辅助向量num[ ]和cpot[ ] 。
num[col]：统计A中第col列中非0元素的个数；
cpot[col] ：指示A中第一个非0元素在b.data中的恰当位置。
