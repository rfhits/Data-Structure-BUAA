# 数组和广义表

数组这种数据结构可以看成是线性表的推广。  
科学计算中涉及到大量的矩阵问题，在程序设计语言中一般都采用数组来存。  
但当矩阵规模很大且具有特殊结构（对角矩阵、三角矩阵、对称矩阵、稀疏矩阵等），  
为减少程序的时间和空间需求，采用**自定义**的描述方式。

数组是一组偶对（下标值，数据元素值）的集合。  
在数组中，对于一组有意义的下标，都存在一个与其对应的值。  
一维数组对应着一个下标值，二维数组对应着两个下标值，如此类推。

数组是由n(n>1)个具有相同数据类型的数据元素a1，a2，…，an组成的有序序列，且该序列必须存储在一块地址连续的存储单元中。

## 数组的特点

数组中的数据元素具有相同数据类型。  
数组是一种随机存取结构：  
给定一组下标，就可以访问与其对应的数据元素。  
数组中的数据元素个数是固定的。

## 数组的顺序表示和实现

数组一般不做插入和删除操作，  
也就是说，数组一旦建立，结构中的元素个数和元素间的关系就不再发生变化。  
因此，一般都是采用顺序存储的方法来表示数组。

计算机的内存结构是一维（线性）地址结构，对于多维数组，将其存放(映射)到内存一维结构时，  
有个次序约定问题。即：
必须按某种次序将数组元素排成一列序列，然后将这个线性序列存放到内存中。

二维数组是最简单的多维数组，以此为例说明多维数组存放(映射)到内存一维结构时的次序约定问题。

### 行优先顺序(Row Major Order)

对于二维m×n数组：  
a_(11), a_(12),..., a_(1n), a(21),..., a(2n),...

a_(ij)对应的地址就是：Loc[a_(11)] + [(i-1) * n + (j-1)] * L  
即：  
Loc[a_(ij)] = Loc[a_(11)] + [(i-1) * n + (j-1)] * L  
L表示每个元素占据的存储单元的大小

对于三维数组：  
Loc[a_(ijk)] = Loc[a_(111)] + [(i-1) * n * p + (j-1) * p + (k-1)] * L

### 列优先顺序(Column Major Order) 

对于二维m×n数组：  
a_(11), a_(21),..., a_(m1), a_(12),..., a_(m2),...

Loc[a_(ij)] = Loc[a_(11)] + [(i-1) + (j-1) * m] * L

## 矩阵的压缩存储

### 对称矩阵

PPT中是以“按行优先存储下三角形（包括对角线）中的元素。”为准。  
用一维数组（向量）sa[0…n(n+1)/2]来存储n阶对称矩阵。  
![以下三角存储对称矩阵中的元素](/img/1-Notes/1-线性表/以“下三角”存储对称矩阵中的元素.jpg)  
![对称矩阵的压缩存储示例](/img/1-Notes/1-线性表/对称矩阵的压缩存储示例.jpg)

K[a_(ij)] = i(i-1)/2 + j  


推导：  
![对称矩阵元素与向量间的对应关系](/img/1-Notes/1-线性表/对称矩阵元素与向量间的对应关系.png)  
若K从0开始，则只需将最后结果减一：  
K[a_(ij)] = i(i-1)/2 + j - 1  
这是i <= j的情况，i > j时，将ij对调即可。

### 三角矩阵

以主对角线划分，三角矩阵有上三角和下三角两种。  
上三角矩阵的下三角（不包括主对角线）中的元素均为常数c(一般为0)。  
下三角矩阵正好相反，它的主对角线上方均为常数。  
![三角矩阵示例](/img/1-Notes/1-线性表/三角矩阵示例.jpg)

看个人喜好，要将常数保存在sa的头还是尾。  
建议保存在尾部，和对称矩阵保持一致。  
以存储下三角矩阵为例：  
K[a_(ij)] = i(i-1)/2 + j - 1  
i > j时，K[a_(ij)] = n(n+1)/2

### 稀疏矩阵(Sparse Matrix)

对于稀疏矩阵，目前还没有一个确切的定义。  
设矩阵A是一个n×m的矩阵中有s个非零元素，设 δ=s/(n×m)，称δ为稀疏因子，  
如果某一矩阵的稀疏因子δ满足δ≦0.05时称为稀疏矩阵。

对于稀疏矩阵，采用压缩存储方法时，只存储非0元素。  
必须存储非0元素的行下标值、列下标值、元素值。  
因此，一个三元组(i, j, a_ij)唯一确定稀疏矩阵的一个非零元素。

    typedef int elemtype;
    typedef struct
    {
        int row;     /*  行下标  */
        int col;     /*  列下标  */
        elemtype value;     /*  元素值  */
    }Triple ;

    typedef struct 
    {   
        int  rn ;   /*   行数：row number   */
        int  cn ;   /*   列数  column number */
        int  tn ;   /*    非0元素个数   */
        Triple   data[MAX_SIZE] ; 
    }TMatrix ;

![稀疏矩阵的三元组表](/img/1-Notes/1-线性表/稀疏矩阵的三元组表.jpg)

## 稀疏矩阵转置

![稀疏矩阵三元组的转置](/img/1-Notes/1-线性表/稀疏矩阵三元组的转置.jpg)

如果直接交换row和col的值，可能导致三元组表的顺序颠倒。

### 遍历col转置

遍历矩阵A的col，  
先是A矩阵col为1的存进矩阵B里；  
然后A矩阵col为2的存进矩阵B里；  
以此类推。

    void TransMatrix(TMatrix a , TMatrix b){
        int p , q , col ;
        b.rn = a.cn;  b.cn = a.rn; b.tn = a.tn;
        if (b.tn == 0){
            printf(“The Matrix A=0\n” );
        }
        else{
            q=0;
            for(col = 1; col <= a.cn; col++){
                for(p = 0; p < a.tn; p++){
                    if(a.data[p].col == col){
                        b.data[q].row = a.data[p].col;
                        b.data[q].col = a.data[p].row; 
                        b.data[q].value = a.data[p].value; 
                        q++ ;
                    }
                }
            }
        }
    }

复杂度为O(cn×tn)，即矩阵的列数和非0元素的个数的乘积成正比。

### 快速转置

如果知道三元表中每一项在转置后的新的三元表中的位置，  
然后直接放进去，可以极大的缩小时间复杂度。

应先求得A中每一列的非0元素个数。
附设两个辅助向量num[ ]和cpot[ ] 。
num[col]：统计A中**第col列**中**非0元素**的个数；
cpot[col]：指示A中第col列第一个非0元素在b.data中的位置。

![稀疏矩阵的三元组表](/img/1-Notes/1-线性表/稀疏矩阵的三元组表.jpg)

![num[col]和cpot[col]](/img/1-Notes/1-线性表/num[col]和cpot[col].jpg)  
解释一下：  
col为1的元素有1个，col为2的元素有2个，col为3的元素有2个……  
转置后，  
col为1的元素们，从1开始放  
col为2的元素们，从2开始放  
col为3的元素们，从4开始放  

现在的问题就变成了，如何从三元组表得到num[] 和 cpot[]。
1. 直接遍历三元组表，得到num[]
2. 再遍历num[]，得到 cpot[]。有 cpot[i] = cpot[i-1] + num[i-1]

之后就是填充MatrixB了，附上代码：

    void  FastTransMatrix(TMatrix a, TMatrix b)
    {
        int p, q, col, k;
        int num[MAX_SIZE], copt[MAX_SIZE];
        b.rn=a.cn;
        b.cn=a.rn;
        b.tn=a.tn;
        if(b.tn==0)
            printf(“ The Matrix A=0\n” );
        else{
            for (col = 1; col <= a.cn; ++col) num[col]=0;   /* 初始化 */
            for(k = 1; k <= a.tn; ++k)
                ++num[a.data[k].col];
        }
        for (cpot[0] = 1, col = 2; col <= a.cn; ++col)
            cpot[col]=cpot[col-1]+num[col-1] ;  /* 生成cpot*/
        
        for (p = 1; p <= a.tn; ++p){    // 利用p遍历A
            col=a.data[p].col;
            q=cpot[col];    // 要放置到B中的q位置
            b.data[q].row=a.data[p].col;
            b.data[q].col=a.data[p].row;
            b.data[q].value=a.data[p].value;
            ++cpot[col];    /* 更新cpot中的值，保证放置的在下一个*/
        }
    }

### 行逻辑链接的三元组顺序表

将cpot[]固定在稀疏矩阵的三元组表中，用来指示“行”的信息  
得到另一种顺序存储结构：行逻辑链接的三元组顺序表。  
其类型描述如下：
    #define MAX_ROW 100
    typedef struct  
    {  
        Triple data[MAX_SIZE] ;     /*  非0元素的三元组表  */  
        int     rpos[MAX_ROW];     /* 各行第一个非0位置表 */ 
        int    rn ,cn , tn ;       /*  矩阵的行、列数和非0元个数  */
    }RLSMatrix ;


## 十字链表

对于稀疏矩阵，  
当非0元素的个数和位置在操作过程中变化较大时，  
采用链式存储结构表示比三元组的线性表更方便。

矩阵中非0元素的结点所含的域有：  
行、列、值、行指针(指向同一行的下一个非0元)、列指针(指向同一列的下一个非0元)。  
其次，十字交叉链表还有一个头结点，结点的结构如图所示。  
![十字链表结点结构](/img/1-Notes/1-线性表/十字链表结点结构.jpg)

至于如何放置，知道就好：  
![](/img/1-Notes/1-线性表/稀疏矩阵及其十字交叉链表.jpg)

## 广义表

广义表是线性表的推广和扩充，在人工智能领域中应用十分广泛。

我们把线性表定义为n(n≧0 )个元素a1, a2 ,…, an的有穷序列，  
该序列中的所有元素具有相同的数据类型且只能是原子项(Atom)。  
所谓原子项可以是一个数或一个结构，  
是指结构上不可再分的。  
若放松对元素的这种限制，容许它们具有其自身结构，  
就产生了广义表的概念。

### 概念

广义表(Lists，又称为列表)，是由n(n≧0)个元素组成的有穷序列：  
LS=(a1，a2，…，an)  
其中ai或者是原子项，或者是一个**广义表**。  
LS是广义表的名字，n为它的长度。  
若ai是广义表，则称为LS的子表。
习惯上：原子用小写字母，子表用大写字母。  
若广义表LS非空时：  
表头：表中第一个元素，即a1；  
表尾：其余元素组成的子表，即(a2，a3，…，an)  
广义表中所包含的元素（包括原子和子表）的个数称为表的长度。  
广义表中括号的最大层数称为表深(度)。  

有关广义表的这些概念的例子如图所示：  
![广义表及其示例](/img/1-Notes/1-线性表/广义表及其示例.jpg)

### 结论

1. 广义表本身可以是一个递归表。自己指向自己，深度为正无穷
2. 根据对表头、表尾的定义，任何一个非空广义表的表头可以是原子，也可以是子表，  
   而表尾必定是广义表，因为尾表指向另一个广义表。

### 存储结构

由于广义表中的数据元素具有不同的结构，通常用链式存储结构表示，  
每个数据元素用一个结点表示。  
因此，广义表中就有两类结点：
1. 表结点，用来表示广义表项，由标志域，**表头指针域**，**表尾指针域**组成，就是图里的圈圈
2. 原子结点，用来表示原子项，由标志域，原子的值域组成

![广义表的链表结点结构示意图](/img/1-Notes/1-线性表/广义表的链表结点结构示意图.jpg)  
tag为表示这是一个原子结点还是一个表结点

对A=()，B=(e)，C=(a, (b, c, d))，D=(A, B, C)，E=(a, E)的广义表的存储结构如下图所示：  
![广义表的存储结构示意图](/img/1-Notes/1-线性表/广义表的链表结点结构示意图.jpg)  
可以发现，每一个原子结点都依附于一个表结点。
