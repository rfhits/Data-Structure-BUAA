# 线索树、树和森林

这一部分讲的是，如何把一棵二叉树变成线性结构，  
以及树、二叉树和森林之间的转化，  
大题只会考后者

## 线索树

一颗有n个结点的二叉树，有n-1条边，  
原因是每加一个结点，树就会多一条边。  
二叉树本身就是对线性结构的一种非线性化。

我们不论是先序、中序还是后序遍历二叉树，  
都是一个线性的访问，即一次只访问一个结点  
相当于按一定的规则将树中的结点排列成一个线性序列，

问题：  
如何找到遍历过程中动态得到的每个结点的直接前驱和直接后继?  
如何保存这些信息？

前面已经提到，一棵二叉树有n个结点，  
则有n-1条边，  
却有n个结点，共有2n个指针域(Lchild和Rchild)，  
若要将其线性化，  
显然有n+1个空闲指针域未用。  
利用这些空闲的指针域来存放结点的直接前驱和直接后继信息

若结点有左孩子，则Lchild指向其左孩子，否则，指向其直接前驱；  
若结点有右孩子，则Rchild指向其右孩子，否则，指向其直接后继；  
为避免混淆,对结点结构加以改进，  
增加两个标志域，如图所示：  
![线索二叉树的结点结构](/img/1-Notes/3-树/线索二叉树的结点结构.jpg)  
要将空闲的指针域利用起来，以存储前驱的信息  
又不能将其和child混淆，所以用tag来做区分。

线索树的逻辑形式如图：  
![线索树的逻辑形式](/img/1-Notes/3-树/线索树的逻辑形式.jpg)


中序线索树的链表结构  
![中序线索树的链表结构](/img/1-Notes/3-树/中序线索树的链表结构.jpg)  
我学习这种指来指去的结构时，常犯的一个错误是，  
指针指向了一个域，  
实际上，指针指向的是一整个结点，而非其中的某个域，  
之所以看起来像是指向了某个域，是在画图时“不得已而为之”

实线表示指针，指向其左、右孩子；  
虚线表示线索，指向其直接前驱或直接后继

在线索树上进行遍历，  
只要先找到序列中的第一个结点，  
然后就可以依次找结点的直接后继结点直到后继为空为止。

### 线索树中查找前驱和后继

查找方式因遍历方式而异

中序线索树为例：  
1. 后继：  
  右tag为1都是线索，直接指示了结点的直接后继，  
  如结点G的直接后继是结点E。  
2. 前驱：
  右tag为0是指针。  
  根据中序遍历的规律，  
  直接后继应当是右子树中最左下的结点。  
  如结点C的直接后继：  
  沿右指针找到右子树的根结点F，然后沿左链往下直到Ltag=1的结点即为C的直接后继结点H。

线索化二叉树：略

### 通过线索遍历二叉树

先序线索二叉树的先序遍历

    void preorder_Thread_bt(BiThrNode *T)
    {
        BiThrNode *p = T;
        while( p != NULL){
            visit(p->data) ;
                if(p->Ltag == 0)
                    p = p->Lchild;
                else
                    p = p->Rchild;
        }
    }

中序线索二叉树的中序遍历

    void inorder_Thread_bt(BiThrNode *T)
    {
        BiThrNode  *p;
        if (T!=NULL){   
            p = T;
        }
        while(p->Ltag == 0)
            p = p->Lchild;   /* 寻找最左的结点，即线索树的头 */

        while (p != NULL){   
            visit(p->data) ;
            if (p->Rtag == 1){   /* 通过右线索找到后继 */
                p = p->Rchild ;
            }    
            else{   /* 否则，右子树的最左结点为后继 */
                p = p->Rchild ; 
                while (p->Ltag == 0 )  p=p->Lchild; 
            }
        }
    }

## 树与森林

本节将讨论树的存储结构、树及森林与二叉树之间的相互转换、树的遍历等。  
大题可能考察树、森林与二叉树的转换。

### 树的存储结构

树的存储结构根据应用的不同而不同。

#### 双亲表示法(顺序存储结构)

用一组**连续**的存储空间来存储树的结点，  
同时在每个结点中附加一个指示器（整数域），用以指示双亲结点的位置（下标值）。  
数组元素及数组的类型定义如下：

    #define MAX_SIZE  100
    typedef  struct PTNode
    {  
        ElemType  data;
        int  parent;
    	PTNode;
    }

    typedef  struct
    {  
        PTNode Nodes[MAX_SIZE] ;
        int root;    /* 根结点位置 */
        int num;   /* 结点数 */ 
        Ptree;
    }

如图所示是一棵树及其双亲表示的存储结构：

![树的双亲存储结构](/img/1-Notes/3-树/树的双亲存储结构.jpg)

这种存储结构利用了任一结点的父结点唯一的性质。  
可以方便地直接找到任一结点的父结点，  
但求结点的子结点时需要扫描整个数组。

#### 孩子链表表示法

树中每个结点有多个指针域，每个指针指向其一棵子树的根结点。有两种结点结构。
1. 定长结点结构  
   指针域的数目就是树的度。  
   其特点是：  
   链表结构简单，但指针域的**浪费**明显。  
   在一棵有n个结点，度为k的树中必有n(k-1)+1空指针域。

2. 不定长结点结构  
   树中每个结点的指针域数量不同，是**该结点**的度，  
   没有多余的指针域，但操作不便。

#### 复合链表结构

![树的孩子链表存储结构](/img/1-Notes/3-树/树的孩子链表存储结构.jpg)

可以看到，至少有两种类型的数据结构，  
一种是顺序存储结构（竖着看），  
一种是链式存储结构（横着看）。

n个结点的树，  
有n个单链表  
而n个头结点又组成一个线性表且以顺序存储结构表示。

#### 孩子兄弟表示法(二叉树表示法)

以二叉链表作为树的存储结构，其结点结构如图所示：  
![孩子兄弟表示法的结点结构](/img/1-Notes/3-树/孩子兄弟表示法的结点结构.jpg)

两个指针域：  
分别指向结点的第一个子结点和下一个兄弟结点。  
结点类型定义如下：

    typedef struct CSnode
    {
        ElemType data;
        struct CSnode *firstchild, *nextsibing;
        CSNode; 
    }

树的孩子兄弟表示存储结构如下图：  
![](/img/1-Notes/3-树/树的孩子兄弟存储结构.jpg)

左节点就是孩子，右结点就是兄弟们，  
所以一个结点的孩子就是自己某个孩子的兄弟们。

### 森林与二叉树的转换

由于二叉树和树都可用**二叉链表**作为存储结构，  
对比各自的结点结构可以看出：  
以二叉链表作为媒介，  
可以导出树和二叉树之间的对应关系。

从物理结构来看，
树和二叉树的**二叉链表**是相同的，  
只是对指针的**逻辑解释**不同而已。

从树的二叉链表表示的定义可知，  
任何一棵和树对应的二叉树，根节点的右子树一定为空。

如图直观地展示了树和二叉树之间的对应关系：  
![树与二叉树的对应关系](/img/1-Notes/3-树/树与二叉树的对应关系.jpg)

### 树转换成二叉树

对于一般的树，转换为二叉树的详细步骤是：
1. 加虚线。  
   在树的每层按从“左至右”的顺序在**兄弟结点**之间**加虚线**相连。
2. 去连线。  
   **除最左**的第一个子结点外，父结点与所有其它子结点的连线都去掉。
3. 旋转。  
   将树顺时针旋转45°，原有的实线左斜。
4. 整型。  
   将旋转后树中的所有虚线改为实线，并向右斜。

该转换过程如图所示：  
![树向二叉树转换的过程](/img/1-Notes/3-树/树向二叉树转换的过程.jpg)

### 二叉树转换成树

对于一棵转换后的二叉树，如何还原成原来的树？其步骤是：
1. 加虚线。  
   若某结点i是其父结点的左子树的根结点，则将该结点i的右子结点以及沿右子链不断地搜索所有的右子结点，  
   将所有这些右子结点与i结点的父结点之间加虚线相连
2. 去连线。  
   去掉二叉树中所有父结点与其右子结点之间的连线
3. 规整化。  
   将图中各结点按层次排列且将所有的虚线变成实线

抓换过程如图所示：  
![二叉树向树转换的过程](/img/1-Notes/3-树/二叉树向树转换的过程.jpg)

### 森林转换成二叉树

当一般的树转换成二叉树后，二叉树根节点的右子树必为空。  
若把森林中第二棵树的根结点作为第一棵树的根结点的**兄弟结点**，  
则可导出森林转换成二叉树的转换算法如下：

设F={T1, T2,⋯,Tn}是森林，则按以下规则可转换成一棵二叉树B=(root，LB，RB)
1. 若n=0，则B是空树。
2. 若n>0，则二叉树B的根是森林T1的根root(T1)，  
   B的左子树LB是B(T11,T12, ⋯,T1m)，其中T11,T12, ⋯,T1m是T1的子树，  
   而其右子树RB是森林F’={T2, T3,⋯,Tn}。

这是一个递归的定义

![森林向二叉树转换的过程](/img/1-Notes/3-树/森林向二叉树转换的过程.jpg)

### 二叉树转换成森林

若B=(root，LB，RB)是一棵二叉树，则可以将其转换成由若干棵树构成的森林：F={T1, T2,⋯,Tn}。

转换算法：
1. 若B是空树，则F为空。
2. 若B非空，则F中第一棵树T1的根root(T1)就是二叉树的根root，  
   T1中根结点的子森林F1是由树B的左子树LB转换而成的森林；  
   F中除T1外其余树组成的的森林F’={T2, T3,⋯,Tn} 是由B右子树RB转换得到的森林。

上述转换规则是递归的，**可以**写出其递归算法。以下给出具体的还原步骤。

1. 去连线。  
   将二叉树B的根结点与其右子结点以及沿右子结点链方向的所有右子结点的连线全部去掉，  
   得到若干棵孤立的二叉树，  
   每一棵就是原来森林F中的树依次对应的二叉树
2. 二叉树的还原。  
   将各棵孤立的二叉树按二叉树还原为树的方法还原成一般的树

![二叉树还原成森林的过程](/img/1-Notes/3-树/二叉树还原成森林的过程.jpg)

### 树和森林的遍历

树的遍历
由树结构的定义可知，树的遍历有二种方法。

1. 先序遍历：  
   先访问根结点，然后依次先序遍历完每棵子树。
2. 后序遍历：  
   先依次后序遍历完每棵子树，然后访问根结点。

说明：
1. 树的先序遍历实质上与将树**转换**成二叉树后对二叉树的先序遍历相同。
2. 树的后序遍历实质上与将树**转换**成二叉树后对二叉树的中序遍历相同。

森林的遍历
设F={T1, T2,⋯,Tn}是森林，对F的遍历有二种方法。
1. 先序遍历：按先序遍历树的方式**依次**遍历F中的每棵树。
2. 中序遍历：按后序遍历树的方式**依次**遍历F中的每棵树。
