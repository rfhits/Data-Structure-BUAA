# 动态查找

当查找表以线性表的形式组织时，  
若对查找表进行插入、删除或排序操作，  
就必须移动大量的记录，当记录数很多时，这种移动的代价很大。  
利用树的形式组织查找表，可以对查找表进行动态高效的查找。

## 二叉排序树(Binary Sort Tree或Binary Search Tree)

二叉排序树(BST)的定义为：  
二叉排序树或者是空树，或者是满足下列性质的二叉树:  
(1) 若左子树不为空，则左子树上所有结点的值(关键字)都小于根结点的值；  
(2) 若右子树不为空，则右子树上所有结点的值(关键字)都大于根结点的值；  
(3) 左、右子树都分别是二叉排序树。

若按中序遍历一棵二叉排序树，所得到的结点序列是一个递增序列。

### BST的查找

查找算法，利用递归：

    BSTNode *BST_Serach(BSTNode *T , KeyType key){  
        if(T==NULL)  return(NULL) ;
        else{  
            if(EQ(T->key, key) )  return(T) ;
            else if (LT(key, T->key))
                return(BST_Serach(T->Lchild, key)) ;
            else
                return(BST_Serach(T->Rchild, key)) ;
        }
    }

### BST的插入

一定插入到叶子节点上

### BST的删除

从BST树上删除一个结点，仍然要保证删除后满足BST的性质。  
设被删除结点为p，其父结点为f，删除情况如下：  
1. 若p是叶子结点： 直接删除p  
2. 若p只有一棵子树：直接用p的子树取代p的位置而成为f的一棵子树。  
3. 若p既有左子树又有右子树：处理方法有以下两种，可以任选其中一种。  
(1) 用p的直接前驱结点代替p。  
从p的左子树中选择**值最大**的结点s，  
s是p的左子树中的最右边的结点**且没有右子树**  
用结点s的内容替换结点p内容，然后删除结点s。  
(2) 用p的直接后继结点代替p。
从p的右子树中选择**值最小**的结点s放在p的位置  
然后删除结点s。

## AVL

BST是一种查找效率比较高的组织形式，但其平均查找长度受树的形态影响较大：  
形态比较均匀时查找效率很好，  
形态明显偏向某一方向时其效率就大大降低。

因此，希望有更好的二叉排序树，其形态总是均衡的，查找时能得到最好的效率，这就是平衡二叉排序树。

平衡二叉排序树(Balanced Binary Tree或Height-Balanced Tree)是在1962年由Adelson-Velskii和Landis提出的，又称AVL树。

平衡二叉树或者是空树，或者是满足下列性质的二叉树:

1. 左子树和右子树深度之差的绝对值不大于1；
2. 左子树和右子树也都是平衡二叉树。

平衡因子(Balance Factor)：二叉树上结点的左子树的深度减去其右子树深度称为该结点的平衡因子。

因此，平衡二叉树上每个结点的平衡因子只可能是-1、0和1，  
否则，只要有一个结点的平衡因子的绝对值大于1，该二叉树就不是平衡二叉树。  
如果一棵二叉树既是二叉排序树又是平衡二叉树，  
称为平衡二叉排序树(Balanced Binary Sort Tree) 

结点类型定义如下：

    typedef  struct  BNode{  
        KeyType  key ;    /*  关键字域  */
        int  Bfactor ;    /*  平衡因子域  */
        …                 /*  其它数据域  */
        struct  BNode  *Lchild , *Rchild ;
    }BSTNode ; 

在插入结点的过程中，不能像普通的二叉树那样插入，要考虑到平衡因子，  
这样会有4需要旋转的情况。

首先自然要画出失衡的情况，然后再找到旋转的方法。

### LL旋转

失衡原因：  
在结点a的**左孩子**的**左子树**上进行插入，插入使结点a失去平衡。

平衡化方法：  
孩子直接变成父亲。孩子现在连了三边，要分一边给降级的父亲。  
这一边就是没被插入的子树。  
![LL型平衡化旋转示意图](/img/1-Notes/5-查找/LL型平衡化旋转示意图.png)

顺时针旋转

比较简单

    void  LL_rotate(BBSTNode *a)
    {  
        BBSTNode *b ;
        b=a->Lchild ; 
        a->Lchild=b->Rchild ;
        b->Rchild=a ;
        a->Bfactor=b->Bfactor=0 ; 
        a=b ;
    }

### LR循转

失衡原因：  
在结点a的**左孩子**的**右子树**上进行插入，插入使结点a失去平衡。

平衡化方法：  
此时LL的方法不再适用于LR，只靠a的孩子是不够的，a的孙子得来，  
得靠a的左孩子的右孩子。即被插入的树的根结点。  
先把孙子变成儿子，再把儿子变成父亲。（真是不堪入目的台词

## 平衡二叉树的插入

平衡二叉排序树的插入操作实际上是在二叉排序插入的基础上完成以下工作：
⑴：判别插入结点后的二叉排序树是否产生不平衡?
⑵：找出失去平衡的最小子树；
⑶：判断旋转类型，然后做相应调整。
失衡的最小子树的根结点a在插入前的平衡因子不为0，且是离插入结点最近的平衡因子不为0的结点的。
若a失衡，从a到插入点的路径上的所有结点的平衡因子都会发生变化，在该路径上还有一个结点的平衡因子不为0且该结点插入后没有失衡，其平衡因子只能是由1到0或由-1到0，以该结点为根的子树深度不变。该结点的所有祖先结点的平衡因子也不变，更不会失衡
