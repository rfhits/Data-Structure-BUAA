# 查找方式

## 索引查找

索引技术是组织大型数据库的重要技术，索引结构的基本组成是索引表和数据表两部分。  
1. 索引表：存储记录的关键字和记录(存储)地址之间的对照表，每个元素称为一个索引项
2. 数据表：存储实际的数据记录

索引表的key的存放不是随机的，  
因为要从索引到数据表进行快速的查找。  
索引表的组织有线性结构和树形结构两种

## 顺序索引表

是将索引项按顺序结构组织的线性索引表，  
而表中索引项一般是按关键字排序的，其特点是：

优点：
1. 可以用折半查找方法快速找到关键字，进而找到数据记录的物理地址，实现数据记录的快速查找；
2. 提供对变长数据记录的便捷访问；
3. 插入或删除数据记录时不需要移动记录，但需要对索引表进行维护。

缺点：
1. 索引表中索引项的数目与数据表中记录数相同，当索引表很大时，检索记录需多次访问外存；
2. 对索引表的维护代价较高，涉及到大量索引项的移动，不适合于插入和删除操作。

线性表的缺点，就是线性索引表的缺点。查找快，移动、更改和删除慢。

## 树形索引表

平衡二叉排序树便于动态查找，因此用平衡二叉排序树来组织索引表是一种可行的选择。  
当用于大型数据库时，所有数据及索引都存储在外存，因此，涉及到内、外存之间频繁的数据交换，这种交换速度的快慢成为制约动态查找的瓶颈。

若以二叉树的**结点**作为内、外存之间数据交换单位，  
一次IO会占一个结点
则查找给定关键字时对磁盘平均进行㏒2n次访问是不能容忍的，  
因此，必须选择一种能尽可能降低磁盘I/O次数的索引组织方式。  
树结点的大小尽可能地接近页的大小。

R.Bayer和E.McCreight在1972年提出了一种多路平衡查找树，称为B_树(其变型体是B+树) 。

## B树

B_树主要用于文件系统中，  
在B_树中，每个结点的大小为一个磁盘页，结点中所包含的关键字及其孩子的数目取决于页的大小。

一棵度为m的B_树称为m阶B_树，其定义是：
一棵m阶B_树，或者是空树，或者是满足以下性质的m叉树：
1. 根结点或者是叶子，或者至少有两棵子树，**至多**有m棵子树
2. 除根结点外，所有非终端结点至少有ceiling(m/2)棵子树，至多有m棵子树
3. 所有叶子结点都在树的同一层上
4. 每个结点应包含如下信息：(n，A0，K1，A1，K2，A2，… ，Kn，An)  
其中Ki(1≤i≤n)是关键字，且Ki < Ki+1 (1≤i≤n-1)；  
Ai为指向孩子结点的指针，  
且Ai-1所指向的子树中所有结点的关键字都小于Ki ，Ai所指向的子树中所有结点的关键字都大于Ki  
n是结点中关键字的个数，且round(m/2)-1≤n≤m-1，n+1为子树的棵数。  
当然，在实际应用中每个结点中还应包含n个指向每个关键字的记录指针

每个结点最左边的数是结点中元素的个数

m阶体现在子树的个数上，结点中的元素个数最多为m-1，  
因为一旦有n个元素，就有n+1个子树的指针。

如图是一棵包含13个关键字的4阶B_树。  
![含13个关键字的4阶B树](/img/1-Notes/5-查找/含13个关键字的4阶B树.png)

### B树代码

结点的定义：

    #define M    5      /*  根据实际需要定义B_树的阶数  */
    typedef  struct BTNode
    {  
        int   keynum;               /*   结点中关键字的个数   */
        struct BTNode *parent;      /*   指向父结点的指针   */
        KeyType  key[M+1];          /*   关键字向量,key[0]未用   */
        struct BTNode  *ptr[M+1];   /*   子树指针向量   */
        RecType   *recptr[M+1];     /*   记录指针向量,recptr[0]未用   */
    
    }BTNode;

查找算法：

    int  BT_search(BTNode *T, KeyType K, BTNode *p)
        //  在B_树中查找关键字K, 
        //  查找成功返回在结点中的位置以及
        //  结点指针p; 否则返回0及最后一个结点指针
    {   
        BTNode *q ; int n ;
        p = q = T;
        while(q != NULL){
            p = q; 
            q->key[0] = K ;      /*   设置查找哨兵   */
            for (n = q->keynum; K < q->key[n]; n--){
                if (n > 0 && EQ(q->key[n], K))
                    return n;
            }
            q = q->ptr[n] ;
        }
        return 0 ;
    }

## B+树

在实际的文件系统中，基本上不使用B_树，而是使用B_树的一种变体，称为m阶B+树。  
它与B_树的主要不同是叶子结点中存储记录。  
在B+树中，所有的非叶子结点可以看成是索引，  
而其中的关键字是作为“分界关键字”，  
用来界定某一关键字的记录所在的子树。

一棵m阶B+树与m阶B_树的主要差异是：
1. 若一个结点有n棵子树，则必含有n个关键字；
2. 所有叶子结点中包含了全部记录的关键字信息以及这些关键字记录的指针，而且叶子结点按关键字的大小从小到大顺序链接；

[B+树](https://blog.csdn.net/qq_35571554/article/details/82759668)

    typedef  enum{branch, left}  NodeType ;
    typedef  struct BPNode
    {   
        NodeTag   tag ;     /*   结点标志   */
        int   keynum ;   /*   结点中关键字的个数   */
        struct BTNode  *parent ;    /*   指向父结点的指针   */
        KeyType  key[M+1] ;     /*   组关键字向量,key[0]未用  */
        union pointer
    {   
        struct BTNode  *ptr[M+1] ; /*   子树指针向量  */
        RecType   *recptr[M+1] ;  /*   recptr[0]未用   */
    }ptrType ;    /*   用联合体定义子树指针和记录指针  */
    }BPNode ;

B+树的插入仅仅在叶子结点上进行。  
当叶子结点中的关键字个数大于m时，“分裂”为两个结点，  
两个结点中所含有的关键字个数分别是ground[(m+1)/2]和ceiling[(m+1)/2]，  
且将这两个结点中的最大关键字提升到父结点中，  
用来替代原结点在父结点中所对应的关键字。  
提升后父结点又可能会分裂，依次类推。

## 哈希查找

基本思想：在记录的存储地址和它的关键字之间建立一个确定的对应关系；这样，不经过比较，一次存取就能得到所查元素的查找方法。

[哈希表](https://www.cnblogs.com/changyaohua/p/4657205.html)
