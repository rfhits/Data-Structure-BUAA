# 有向无环图及其应用

## 有向无环图(Directed Acycling Graph)

是图中没有回路（环）的有向图。  
是一类具有代表性的图，主要用于研究工程项目的工序问题、工程时间进度问题等。

一个工程(project)都可分为若干个称为活动(active)的子工程(或工序)，各个子工程受到一定的条件约束：  
某个子工程必须开始于另一个子工程完成之后；  
整个工程有一个开始点(起点)和一个终点。

人们关心：

1. 工程能否顺利完成?影响工程的关键活动是什么?

2. 估算整个工程完成所必须的最短时间是多少?

## AOV(Activity On Vertex Network)

对工程的活动加以抽象：  
图中顶点表示活动，有向边表示活动之间的优先关系，  
这样的有向图称为顶点表示活动的网(Activity On Vertex Network)。

### 判断有向图是否存在回路算法

设计到全序偏序等概念，所以简化说明。

一个AOV网，肯定有结点入度为0，这些事件作为整个工程的开始。  
完成了工程的“开始”后，继续做剩下的活动。

将做完的事从AOV网中剔除，剩下的工程，肯定有入度为0的结点，回到开始。

更专业地说，这个叫做“拓扑排序”

简单地说，就是按照入度和出度来排的序

![有向图的拓扑排序](/img/1-Notes/6-图/有向图的拓扑排序.png)

#### 算法具体过程

1. 采用正邻接链作为AOV网的存储结构

2. 设立堆栈，用来暂存入度为0的顶点

3. 删除顶点以它为尾的弧：弧头顶点的入度减1。
算法实现

核心就是统计每个点的入度和出度找到出度为0的点，然后删除出度为0的点，删除边、修改入度。

如果在这个过程中，如果找不到出度为0的结点，则含环，过程结束。

#### 算法复杂度分析

设AOV网有n个顶点，e条边，则算法的主要执行是：

1. 统计各顶点的入度：时间复杂度是O(n+e)

2. 入度为0的顶点入栈：时间复杂度是O(n)

3. 排序过程：顶点入栈和出栈操作执行n次，入度减1的操作共执行e次，时间复杂度是O(n+e)

因此，整个算法的时间复杂度是O(n+e)。

## AOE(Activity On Edge)

与AOV网相对应的是AOE(Activity On Edge)，  
是边表示活动的有向无环图。

如图所示。图中顶点表示事件(Event)，  
每个事件表示在其前的所有活动已经完成，其后的活动可以开始；  
弧表示活动，弧上的权值表示相应活动所需的时间或费用。

![AOE网](/img/1-Notes/6-图/AOE网.png)

### 与AOE有关的研究问题

1. 完成整个工程至少需要多少时间?

2. 哪些活动是影响工程进度(费用)的关键?

工程完成最短时间：  
从起点到终点的**最长**路径长度（路径上各活动持续时间之和）。  
长度最长的路径称为关键路径，  
关键路径上的活动称为关键活动。

事件的最早发生时间ve[k]：  
ve[k]是指从始点开始到顶点vk的最大路径长度。这个长度决定了所有从顶点vk发出的活动能够开工的最早时间。

事件的最迟发生时间vl[k]：  
vl[k]是指在不推迟整个工期的前提下,事件vk允许的最晚发生时间。

活动的最早开始时间e[i]：  
若活动ai是由弧<vk, vj>表示，则活动ai的最早开始时间应等于事件vk的最早发生时间。因此，有：e[i]=ve[k]

活动的最晚开始时间l[i]：  
活动ai的最晚开始时间是指，在不推迟整个工期的前提下， ai必须开始的最晚时间。若ai由弧<vk，vj>表示，则ai的最晚开始时间要保证事件vj的最迟发生时间不拖后。因此，有：l[i]=vl[j]-len<vk,vj>

### 求AOE中关键路径和关键活动

#### 算法思想

1. 要找出一个AOE网中的关键路径，就要先找出网里的关键事件，这些关键事件间的路径就是关键路径。

2. 利用拓扑排序求出AOE网的一个拓扑序列

3. 从拓扑排序的序列的第一个顶点（源点）开始，按拓扑顺序依次计算每个事件的最早发生时间ve(i)

4. 从拓扑排序的序列的最后一个顶点(汇点)开始，按逆拓扑顺序依次计算每个事件的最晚发生时间vl(i)

ve(i)=vl(i)则为关键事件。

#### ve(j)的计算方法

j是起点时：
ve(j) = 0

j是不是终点时，<i, j>是网中的弧：
ve(j) = Max{ve(i) + dut(<i, j>)}

#### vl(j)的计算方法

j是终点时：  
vl(j) = ve(n-1)  
也就是说，终点的最早也是最晚开始。  
终点一定在关键路径上

j不是终点时，<j, k>是网中的弧：  
vl(j) = Min{vl(k)-dut(<j, k>)}

选择ve和vj相等的点，就是是关键路径上的点。

## 最短路径

若用带权图表示交通网，图中顶点表示地点，边代表两地之间有直接道路，边上的权值表示路程(或所花费用或时间)。

从一个地方到另一个地方的路径长度表示该路径上各边的权值之和。问题：

1. 两地之间是否有通路?

2. 在有多条通路的情况下，哪条最短?

考虑到交通网的有向性，直接讨论的是带权有向图的最短路径问题，但解决问题的算法也适用于无向图。

将一个路径的起始顶点称为源点，最后一个顶点称为终点。

单源点最短路径：  
对于给定的有向图G=(V，E)及单个源点Vs，求Vs到G的其余各顶点的最短路径。

### 迪杰斯特拉算法(Dijkstra)

从源点开始，向外扩散。  
设置顶点集合S并不断地作贪心选择来扩充这个集合。  
一个顶点属于集合S当且仅当从源到该顶点的最短路径长度已知。

1. 初始化dist和pre，dist中存储目前认为的最短路径，pre存储该点的上一结点

2. 从dist中挑一条最短的路径，并将点加入到S中

3. 利用刚加入的点，更新dist和pre

4. 重复2和3，直到S补全

![一个带权有向图](/img/1-Notes/6-图/迪杰斯特拉算法图-1.png)

![dist和pre的变化](/img/1-Notes/6-图/迪杰斯特拉算法图-2.png)

复杂度为O(n^3)

### Floyd算法

[Floyd](https://www.cnblogs.com/wangyuliang/p/9216365.html)

复杂度为O(n^3)

接邻矩阵的一个不断变化的过程。

想要让两点之间的路径变短
当允许v0作为中转时，更新接邻矩阵；  
当允许v0和v1作为中转时，更新接邻矩阵；  
但允许v0、v1和v2作为中转时，更新接邻矩阵。

    for (i = 1; i <= n; i++){
        for (j = 1; j <= n; j++){
            if (e[i][j] > e[i][1] + e[1][j])
                e[i][j] = e[i][1] + e[1][j];
        }
    }
