# 内部排序

废话少说，学不完了。

## 排序的相关概念

### 排序的稳定性

若记录序列中有两个或两个以上关键字相等的记录：  
Ki = Kj(i≠j)，且在排序前Ri先于Rj(i < j)，  
排序后的记录序列仍然是Ri先于Rj，  
称排序方法是稳定的，  
否则是不稳定的。

排序算法有许多，但就全面性能而言，还**没有**一种公认为**最好**的。  
每种算法都有其优点和缺点，分别适合不同的数据量和硬件配置。  
评价排序算法的标准有：执行时间和所需的辅助空间，其次是算法的稳定性。

### 排序的分类

待排序的记录数量不同，排序过程中涉及的存储器的不同，有不同的排序分类。

1. 待排序的记录数不太多：  
   所有的记录都能存放在内存中进行排序，称为内部排序；
2. 待排序的记录数太多：所有的记录不可能存放在内存中，  
   排序过程中必须在内、外存之间进行数据交换，  
   这样的排序称为外部排序。

### 内部排序的基本操作

对内部排序地而言，其基本操作有两种：
1. 比较两个关键字的大小；
2. 存储位置的移动：从一个位置移到另一个位置。
   
第一种操作是必不可少的；  
而第二种操作却不是必须的，取决于记录的存储方式，  
具体情况是：
1. 记录存储在一组连续地址的存储空间：  
   记录之间的逻辑顺序关系是通过其物理存储位置的相邻来体现，  
   记录的移动是必不可少的；
2. 记录采用链式存储方式：  
   记录之间的逻辑顺序关系是通过结点中的指针来体现，  
   排序过程仅需修改结点的指针，而不需要移动记录
3. 记录存储在一组连续地址的存储空间：  
   构造另一个辅助表来保存各个记录的存放地址（指针）：  
   排序过程不需要移动记录，而仅需修改辅助表中的指针，  
   排序后视具体情况决定是否调整记录的存储位置。

1.比较适合记录数较少的情况；而2.、3.则适合记录数较多的情况。

为讨论方便，假设待排序的记录是以1.的情况存储，  
且设排序是按升序排列的；关键字是一些可直接用比较运算符进行比较的类型。

## 插入排序

最基本的插入排序是**直接插入排序**——(Straight Insertion Sort)

![直接插入排序的过程](/img/1-Notes/6-排序/直接插入排序的过程.jpg)

### 算法分析

最好情况：  
比较次数n-1，移动次数2(n-1)

最坏情况：  
比较次数：(n-1)(n+1)/2，移动次数：(n-1)(n+4)/2

## 希尔排序

将元素分若干小组，在不同的组间进行插入排序，  
排好后，  
将组的length逐渐扩大，组数减小，组内再进行插入排序，  
最后，所有元素一个组，再插入排序

知道“增量”的概念：  
增量是“5”，则下标差5的元素们一个组；  
增量是“3”，则下标差3的元素们一个组；  
增量是“1”，则下标差1的元素们一个组，即所有元素一个组。

![希尔排序](../../img/1-Notes/6-排序/希尔排序.png)

[希尔排序解析](https://www.cnblogs.com/chengxiao/p/6104371.html)

## 快速排序

是一类基于交换的排序，  
系统地交换反序的记录的偶对，直到不再有这样一来的偶对为止。  
其中最基本的是冒泡排序(Bubble Sort)。

### 冒泡排序

我们假设排好后左小右大，  
每次拿到一个偶对，要把大的放到右边，  
整个数组扫描一遍，n-1个偶对，  
扫完以后，最大的数跑到最右边去了

![冒泡排序过程](/img/1-Notes/6-排序/冒泡排序过程.jpg)

      #define FALSE 0
      #define TRUE 1
      void Bubble_Sort(Sqlist *L){
         int j, k, flag;
         for(j = 0; j < L->length; j++){       /* 共有n-1趟排序 */
            flag=TRUE ;
            for(k = 1; k <= L->length - j; k++){   /*   一趟排序   */
               if(L->R[k+1].key < L->R[k].key){   
                  flag = FALSE; 
                  L->R[0]=L->R[k];
                  L->R[k]=L->R[k+1]; 
                  L->R[k+1]=L->R[0];  
               }
            }
            if  (flag == TRUE)  break;
         }
      }

设置flag，检查这一次检测中还有没有逆序的偶对，提高效率

### 真正的快速排序

[快排解析](https://blog.csdn.net/nrsc272420199/article/details/82587933)

关键是找到一个函数，  
给一个数组，能够将里面的元素分到一个基准两边。  
比如，给[4,9,2,7,3,8]，  
挑基准为4，则经过这个函数后，数组变成：  
[2,3,4,9,7,8]，  
就是被分到了4的两边。  
然后再对4两边调用这个函数。

一般来说，挑第一个作为基准，叫temp  
设置两个标志，low和high，分别对应第一个和最后一个元素。  

从high往low方向扫描，  
若arr[high] >= tmp, high--  
若arr[high] < tmp，  
需要将arr[high]直接赋值给arr[low]，low++，**覆盖掉tmp**，  
但是，high不要动，放在这里，现在arr中有两个arr[high]了，后面那个我们是不要的  
到时候，也可以直接覆盖掉arr[high]  
扫描来到了low这边，  
low再和tmp比，  
若arr[low] <= tmp, low++  
若arr[low] > tmp  
arr[low]直接赋值给arr[high]，把arr[high]给覆盖掉，high--

直到low和high相等，ok，tmp赋值到arr[low]，  
这样，一个数组的元素们，就成功被分到了两边

![快排图解](/img/1-Notes/6-排序/快排图解.jpg)

      int quick_one_pass(Sqlist  *L ,int low, int high)
      {
         int i = low, j = high;
         L->R[0] = L->R[i];       /*   R[0]作为临时单元和哨兵  */
         do{
            while (LQ(L->R[0].key, L->R[j].key)&&(j>i))
               j--;
            if  (j>i){  
               L->R[i] = L->R[j] ; 
               i++;   
            }
            while (LQ(L->R[i].key, L->R[0].key)&&(j>i)) i++ ;
            if (j>i){  
               L->R[j] = L->R[i]; 
               j--;   
            }
         } while(i!=j);    /* i=j时退出扫描  */
         L->R[i] = L->R[0] ; 
         return(i) ;
      }

递归实现快排

      void quick_Sort(Sqlist *L, int low, int high)
      {  
         int k ;
         if (low < high){
            k=quick_one_pass(L, low, high);
            quick_Sort(L, low, k-1);
            quick_Sort(L, k+1, high);
         }     
         /* 序列分为两部分后，分别对每个子序列排序 */
      }

性能分析：  
快排不稳定  
平均时间复杂度：O(nlogn)  
堆栈最大深度：[log2n]+1  
最坏情况：每次的tmp都是最大或最小的，复杂度O(n^2)


## 直接选择排序

选择排序(Selection Sort)的基本思想是：  
每次从当前**待排序**的记录中选取关键字最小的记录表，  
然后与待排序的记录序列中的第一个记录进行**交换**，  
直到整个记录序列有序为止。 

![直接选择排序的过程](/img/1-Notes/6-排序/直接选择排序的过程.jpg)

时间复杂度是：T(n)=O(n2)  
空间复杂度是：S(n)=O(1)  
直接选择排序是不稳定的

## 堆排序

数组[2,5,7,9,3,6,1,4]  
两两一组：  
2和5比，5大；  
7和9比，9大；  
3和6比，6大；  
1和4比，4大；  
得到[5,9,6,4]  
再两两比较，得到[9,6]  
再比较，得到最大的9

实际的比较过程中，  
将这个数组视为一棵完全二叉树，  
通过不断地交换，把最大的元素放到最顶端，  
然后和最后的元素交换

[堆排序图文解析](https://www.cnblogs.com/chengxiao/p/6129630.html)

![堆排序过程](/img/1-Notes/6-排序/堆排序过程.jpg)

## 二路归并排序

一张图看懂：  
![归并排序过程](/img/1-Notes/6-排序/归并排序过程.png)

我觉得，和两个有序链表的合并非常像

[归并排序解析](https://blog.csdn.net/weixin_45857153/article/details/110474615)

具有n个待排序记录的归并次数是㏒2n，  
而一趟归并的时间复杂度为O(n)，  
则整个归并排序的时间复杂度无论是最好还是最坏情况均为O(n㏒2n)。

在排序过程中，使用了辅助向量DR，大小与待排序记录空间相同，则空间复杂度为O(n)。  
归并排序是稳定的。

## 基数排序

“位”的英文是“digit”  
按照个位、十位、百位、……慢慢排

“桶”理解成这一位(digit)为某个数的一个容器。

分为“分配”和“收集两个阶段”。

“分配”就是放到把某一位相同的数放到一起。 

![基数排序-第1趟分配与收集](/img/1-Notes/6-排序/基数排序-第1趟分配与收集.jpg)


第一趟，比的是个位，  
个位为0的放到f[0]e[0]之间，就是放到了位为0的桶里  
个位为1的放到f[1]e[1]之间，就是放到了位为1的桶里
……


第二趟分配和收集类似  
![](/img/1-Notes/6-排序/基数排序-第2趟分配与收集.jpg)

第三趟，我们可以看到，“桶”的概念发挥出来了，  
1039和0066的百位都是0，所以放到了桶[0]里；  
3355和4382的百位都是3，所以放到了桶[3]里；  
……
![](/img/1-Notes/6-排序/基数排序-第3趟分配与收集.jpg)

到了第4趟，就分完了
![](/img/1-Notes/6-排序/基数排序-第4趟分配与收集.jpg)

这个是从小往大的排，叫做LSD，Least Significant Digit first。  
从大往小的排叫做MSD，Most Significant Digit first。

## 总结

![主要内部排序算法的性能](/img/1-Notes/6-排序/主要内部排序算法的性能.jpg)