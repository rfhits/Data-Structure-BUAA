# 图的遍历

1. 明确地说明，对这种无穷无尽的数据结构，递归的思想是必不可少的。

2. 仅仅对图中的一个点进行遍历，（不论是DFS或是BFS），不能保证遍历整个图。  
因为可能有“孤点”。

3. 李波老师的PPT中，采用邻接链表这种结构进行遍历，这也并不代表其他类型的数据结构不行。

如果用邻接矩阵来描述，我觉得会更简单一些。

因为接邻矩阵matrix[i]所对应的一个list，就存储着vi所接邻的点

## 深度优先遍历(Depth First Search)

要使用一个list存储已经访问过的点，

因为仅仅对一个点进行DFS不能保证遍历整个图，
所以对所有的点都得来一次DFS，当然，前提是这些点不曾在某次DFS中被访问过。

    for v in vexs:
        if v in traveled:
            pass
        else :
            Execute(v)
            traveled.append(v)
            DFS(v)

tra()这个函数，接受结点，先访问这个结点里的数据，再添加到traveled里。  
然后，“按照顺序”，这个顺序，  
既可以是邻接矩阵里v对应的那一行的顺序，也可以是v对应的邻接链表的顺序。  
找到v相邻接且不曾访问的结点，对此点进行DFS

如果某个点没有邻接的点或是邻接的点都被访问过了，那么直接return。

### 复杂度分析

遍历时，对图的每个顶点至多调用一次DFS函数。  
其实质就是对每个顶点查找邻接顶点的过程。

当图有e条边，其时间复杂度为O(e)，总时间复杂度为O(n+e)。

## 广度优先遍历(Breadth First Search)

同样地，对所有点来一次BFS，具体的某一次BFS，也顺序查找邻接点。  
但是访问邻接点数据和对邻接点进行DFS的顺序有所不同。

这就好像二叉树的结构下，要按层来遍历一样，不太舒服。

因为找到了邻接点以后，只按顺序访问，  
然后再回过头来对每个点进行BFS，  
所以考虑增加一个“中间数组”记录回过头来的顺序。

    def BFS(vex):
        for v in matrix[vex]:
            if v in traveled:
                pass
            else :
                Execute(v)  # 访问数据
                traveled.append(v)
                back.append(v)  # back就是中间数组
            for v in back:
                BFS(v)
            clean(back)

### 复杂度分析

用广度优先搜索算法遍历图与深度优先搜索算法遍历图的唯一区别是邻接点搜索次序不同，  
因此，广度优先搜索算法遍历图的总时间复杂度为O(n+e)。
