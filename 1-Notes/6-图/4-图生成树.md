# 图生成树

## 图的（强）连通性问题

### 回忆

>对无向图G=(V,E)  
若从V中任意取两点，vi和vj都是连通的，  
则称图G是连通图，  
否则称G为非连通图。  
>若G是非连通图，则极大的连通子图称为G的连通分量。

以上是无向图

>对有向图G=(V，E)，  
若从V中任意取两点，都有  
以vi为起点，vj为终点  
以及以vj为起点，vi为终点的有向路径，  
称图G是强连通图，  
否则称G为非强连通图。  
若G是非强连通图，则极大的强连通子图称为G的强连通分量。

形象地说，“连通”就是一块完整的网，“网”上面交错相通。

“连通分量”这个概念，适用于一个包含着数个“网”的图，  
这个图内的任何一个“网”，都是连通分量。

“极大”的含义：指的是对子图再增加图G中的其它顶点，子图就不再连通。

### 无向图的连通分量

对无向图进行遍历时：  
若是连通图：仅需从图中任一顶点出发，就能访问图中的所有顶点；  
若是非连通图：需从图中多个顶点出发。每次从一个新顶点出发所访问的顶点集序列恰好是各个连通分量的顶点集；

### 无向图的生成树

#### 连通图

若G=(V,E)是无向连通图，  
顶点集和边集分别是V(G)，E(G)。
若从G中任意点出发遍历时，E(G)被分成两个互不相交的集合：

1. T(G)：遍历过程中所经过的边的集合；

2. B(G)：遍历过程中未经过的边的集合；

显然：E(G)=T(G)∪B(G)，T(G)∩B(G)=Ø  
显然，图G’=(V, T(G))是G的极小连通子图，且G’是一棵树。G’称为图G的一棵生成树。

从任意点出发  
按DFS算法得到的生成树称为深度优先生成树  
按BFS算法得到的生成树称为广度优先生成树。

#### 非连通图

非连通图得到的是森林

若G=(V,E)是无向非连通图，  
对图进行遍历时得到若干个连通分量的顶点集：  
V1(G), V2(G), …, Vn(G)  
和相应所经过的边集：  
T1(G), T2(G), …, Tn(G)  
则对应的顶点集和边集的二元组：Gi=(Vi(G),Ti(G))
(1≦i≦n)是对应分量的生成树

所有这些生成树构成了原来非连通图的生成森林。

说明：  
当给定无向图要求画出其对应的生成树或生成森林时，必须先给出相应的邻接表，然后才能根据邻接表画出其对应的生成树或生成森林。

### 有向图的强连通分量

有向图的强连通分量，形象地说，是一个环。

如何求一个有向图的强连通分量？

求有向图G的强连通分量的基本步骤是：

1. 对G进行深度优先遍历，生成G的深度优先生成森林T。

2. 对森林T的顶点按**中序遍历**顺序进行编号

3. 改变G中每一条弧的方向，构成一个新的有向图G’。

4. 按2中标出的顶点编号，从编号最大的顶点开始对G’进行深度优先搜索，得到一棵深度优先生成树。  
若一次完整的搜索过程没有遍历G’的所有顶点，则从未访问的顶点中选择一个编号最大的顶点，由它开始再进行深度优先搜索，并得到另一棵深度优先生成树。  
每一次深度优先搜索所得到的生成树中的顶点就是G的一个强连通分量的所有顶点。

5. 重复步骤⑷ ，直到G’中的所有顶点都被访问

在算法实现时，建立一个数组in_order[n]存放深度优先生成森林的中序遍历序列。  
对每个顶点v，在调用DFS函数结束时，将顶点依次存放在数组in_order[n]中。图采用十字链表作为存储结构最合适。

简要地说，就是生成DFStree、编号，反向DFS，取交集。  
因为一个环，将所有的边反向，还是一个环，任意两点可达。

## 连通图的最小生成树

构造最小生成树的算法有许多，基本原则是：

1. 尽可能选取权值最小的边，但不能构成回路  

2. 选择n-1条边构成最小生成树。

### Prim算法

从已经选择的点进行“扩散”，长出一张网。

基本步骤：

1. 若从顶点v0出发构造，U={v0}，T={}；

2. 从已选点邻接的边中，选择  
权值最小、并且不会在已有的子图里生成环  
的一条边，加到边集里，再补充点集。

3. 重复直到U=V为止。则T中必有n-1条边， G=(U,TE)就是最小生成树。

如下图：

![Prime算法构造最小生成树](/img/1-Notes/6-图/Prime算法构造最小生成树.png)

#### Prim算法复杂度分析

设带权连通图有n个顶点，则算法的主要执行是二重循环：

1. 求closedge中权值最小的边，频度为n-1

2. 修改closedge数组，频度为n

因此，整个算法的时间复杂度是O(n^2)，与边的数目无关。

### Kruskal算法

Kruskal算法是有很强的“择边”的思想。

对G中的边按权值大小从小到大依次选取。

1. 选取权值最小的边(vi,vj)，  
若边(vi,vj)加入到TE后形成回路，则舍弃该边  
否则，将该边并入到TE中，即TE=TE∪{(vi，vj)}

2. 重复1，直到TE中包含有n-1条边为止。

问题的关键是如何判断这条边加到边集里，会不会生成回路。

#### 判断回路算法

定义一维数组Vset[n] ，存放图T中每个顶点所在的连通分量的编号。

1. 初值：Vset[i]=i，表示每个顶点各自组成一个连通分量，连通分量的编号简单地使用顶点在图中的位置(编号)。

2. 当往T中增加一条边(vi,vj) 时，先检查Vset[i]和Vset[j]值：  
☆ 若Vset[i]=Vset[j]：表明vi和vj处在同一个连通分量中，加入此边会形成回路；  
☆ 若Vset[i]≠Vset[j]，则加入此边不会形成回路，将此边加入到生成树的边集中。

3. 加入一条新边后，将两个不同的连通分量合并：将一个连通分量的编号换成另一个连通分量的编号。

#### Kruskal算法复杂度分析

设带权连通图有n个顶点，e条边，则算法的主要执行是：

1. Vset数组初始化：时间复杂度是O(n)

2. 边表按权值排序：若采用堆排序或快速排序，时间复杂度是O(e㏒e)

3. while循环：最大执行频度是O(n)，其中包含修改Vset数组，共执行n-1次，时间复杂度是O(n2)

故整个算法的时间复杂度是O(e㏒e+n2) 。
