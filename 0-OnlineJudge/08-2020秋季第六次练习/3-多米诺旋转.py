# 【问题描述】
#  在一排多米诺骨牌中，A[i] 和 B[i] 分别代表第 i 个多米诺骨牌的上半部分和下半部分。（一个多米诺是两个从 1 到 6 的数字同列平铺形成的 —— 该平铺的每一半上都有一个数字。）
#  我们可以旋转第 i 张多米诺，使得 A[i] 和 B[i] 的值交换。
#  返回能使 A 中所有值或者 B 中所有值都相同的最小旋转次数。
#  如果无法做到，返回 -1.


# 【输入形式】
#     第一行，一个整数n，表示多米诺牌的数量。
#     接下来n行，每行一个数字，依次表示每个多米诺牌的上半部分。
#     接下来n行，每行一个数字，依次表示每个多米诺牌的下半部分。


# 【输出形式】
# 一行，一个整数，表示能使 A 中所有值或者 B 中所有值都相同的最小旋转次数。不能做到就返回-1

# 【样例输入】
#     6
#     2
#     1
#     2
#     4
#     2
#     2
#     5
#     2
#     6
#     2
#     3
#     2

# 【样例输出】
#     2


n = int(input())
a = []        # 存成[(),(),()]
which = 0    # 第一张牌的上还是下来做
cnt = 0
for i in range(n):
    a.append([int(input()), 0])
for i in range(n):
    a[i][1] = int(input())

t = a[0][0]     # 看看a[0][0]能不能作为公共的那个数
can0 = 1        # 默认可以
for i in a:
    if t not in i:
        can0 = 0

t = a[0][1]     # 看看a[0][1]能不能作为公共的那个数
can1 = 1
for i in a:
    if t not in i:
        can1 = 0

if ((can0 or can1) == 0):
    print(-1)
else:
    if can0 == 1:
        t = a[0][0]     # 此处有一个bug，a[0][1]可能比a[0][0]翻转的次数要更少，但是优先考虑了a[0][0]
    else:
        t = a[0][1]
        which = 1

    for i in range(1, n):
        if a[i][which] != t:
            cnt += 1
    if cnt*2 > n:
        print(n-cnt)
    else:
        print(cnt)
